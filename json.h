#ifndef JSON_H
#define JSON_H
/*

freddy

A thin C++11 STL wrapper for reading/writing JSON


Copyright (c) 2014 Chris Bush

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
   distribution.


*/
/*! @mainpage Freddy vs. JSON
 *
 * This documentation is generated by doxygen.
 *
 */


#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <memory>
#include <sstream>
#include <iterator>


/**
 * @brief contains classes and functions for handling json
 **/
namespace json {


class value;


/**
 * @brief The string type is really a std::string
 **/
using string = std::string;


/**
 * @brief The json object is really a std::map<string, @ref value>
 **/
using object = std::map<string, value>;


/**
 * @brief The array is really a std::vector<@ref value>
 **/
using array = std::vector<value>;


/**
 * @brief The number is really a double
 * @warning This will probably change soon
 **/
using number = double;


std::ostream& operator<<(std::ostream&, object const&);
std::ostream& operator<<(std::ostream&, array const&);


/**
 * @brief Create an escaped string from an unescaped string.
 * @param value an unescaped string
 * @return an escaped string
 **/
string escape(string const& value);


/**
 * @brief Create an unescaped string from an escaped string.
 * @param value an escaped string
 * @return an unescaped string
 **/
string unescape(string const& value);


/**
 * @brief Interface of json string-like classes.
 **/
class stringlike {
  public:
    virtual ~stringlike(){}

    /**
     * @return an unescaped string representation of this instance.
     **/
    virtual string to_json_string() const =0;
};


/**
 * @brief Interface of json object-like classes.
 **/
class objectlike {
  public:
    virtual ~objectlike(){}

    /**
     * @return a representation of this instance as a json::object (i.e. std::map<string, json::value>).
     **/
    virtual object const& to_json_object() const =0;
};


/**
 * @brief Interface of json array-like classes.
 **/
class arraylike {
  public:
    virtual ~arraylike(){}

    /**
     * @return a representation of this instance as a json::array (i.e. std::vector<json::value>).
     **/
    virtual array const& to_json_array() const =0;
};


/**
 * @brief basic exception related to json operations
 **/
class exception : public std::exception {
  protected:
    std::string msg;

  public:
    /**
     * @brief construct an empty exception (not recommended, but meh)
     **/
    exception(){}

    /**
     * @brief construct a general json exception with a given message
     * @param msg detail about the exception
     **/
    exception(const char * msg)
      : msg(msg)
      {}

    /**
     * @brief construct a general json exception with a given message
     * @param msg detail about the exception
     **/
    exception(std::string const& msg)
      : msg(msg)
      {}

    virtual ~exception(){}

    /**
     * @return An message describing the exception.
     **/
    virtual const char * what() const noexcept {
      return msg.c_str();
    }

};


/**
 * @brief an exception for malformed json
 **/
class bad_json : public exception {
  public:
    /**
     * @brief construct a default bad json exception
     **/
    bad_json()
      : exception("bad json exception: malformed json")
      {}

    /**
     * @brief construct a bad json exception with a given message
     * @param msg detail about the exception
     **/
    bad_json(const char * msg)
      : exception(msg)
      {}

    /**
     * @brief construct a bad json exception with a given message
     * @param msg detail about the exception
     **/
    bad_json(std::string const& msg)
      : exception(msg)
      {}

    ~bad_json(){}

};


/**
 * @brief enumeration of the possible json value types
 **/
enum ValueType {
  JSON_ARRAY,
  JSON_BOOL,
  JSON_NULL,
  JSON_NUMBER,
  JSON_OBJECT,
  JSON_STRING,
};


namespace detail {
  class value_t;
}

/**
 * @brief Represents any json data type.
 **/
class value {
  protected:
    std::shared_ptr<detail::value_t> _value;
    ValueType _type;

  public:
    /**
     * Construct an empty value
     **/
    value();

    /**
     * Construct a value with an array (or std::vector<value>)
     * @param x the array to store in the value
     **/
    value(array const& x);

    /**
     * Construct a value with an @ref arraylike object
     * @param x the array to store in the value
     **/
    value(arraylike const& x);

    /**
     * Construct a value with a bool
     * @param x the bool to store in the value
     **/
    value(bool x);

    /**
     * Construct a value with a floating-point value
     * @param x The floating-point value to store as a number
     **/
    value(double x);

    /**
     * Construct a value with an integral value
     * @param x The integral value to store as a number
     **/
    value(int x);

    /**
     * Construct a value with a json object (or std::map<string, value>)
     * @param x The object to store in the value
     **/
    value(object const& x);

    /**
     * Construct a value with an @ref objectlike object
     * @param x The object to store in the value
     **/
    value(objectlike const& x);

    /**
     * Construct a value with a string
     * @param x The string to store in the value
     **/
    value(string const& x);

    /**
     * Construct a value with a null-terminated C-string
     * @param x The string to store in the value
     **/
    value(const char * const& x);

    /**
     * Construct a value with a @ref stringlike object
     * @param x The string to store in the value
     **/
    value(stringlike const& x);

  public:
    virtual ~value();

    /**
     * Copy constructor
     * @param v the value to copy
     **/
    value(value const& v);

    /**
     * Copy assignment operator
     * @param v the value to copy
     * @return a reference to this object
     **/
    value& operator=(value const& v);

  public:
    /**
     * @return the value represented in json string form
     **/
    inline string json() const;

    /**
     * @return the json @ref ValueType of the value
     */
    inline ValueType type() const;

    /**
     * @return true if the value represents an array
     **/
    bool is_array() const;
    array const& get_array() const;
    array& get_array();
    explicit operator array&();

    /**
     * @return true if the value represents a bool
     **/
    bool is_bool() const;
    bool const& get_bool() const;
    bool& get_bool();
    explicit operator bool&();

    /**
     * @return true if the value is null
     **/
    inline bool is_null() const;

    /**
     * @return true if the value represents a number
     **/
    inline bool is_number() const;
    number const& get_number() const;
    number& get_number();
    explicit operator number&();

    /**
     * @return true if the value represents an object
     **/
    inline bool is_object() const;
    object const& get_object() const;
    object& get_object();
    explicit operator object&();

    /**
     * @return true if the value represents a string
     **/
    inline bool is_string() const;
    string const& get_string() const;
    string& get_string();
    explicit operator string&();

};


/**
 * @brief Put a json @ref value to an ostream object as json
 **/
std::ostream& operator<<(std::ostream& o, value const& v);


/**
 * @brief Put a json @ref array to an output stream as json
 **/
std::ostream& operator<<(std::ostream& o, array const& v);


/**
 * @brief Put a json @ref object to an output stream as json
 */
std::ostream& operator<<(std::ostream& o, object const& v);




/**
 * @brief parse json into a @ref value
 * @param s the well-formed json to parse
 * @return the parsed json as a @ref value
 * @throw @ref exception if parsing failed
 **/
value parse(string const& s);



} // namespace json


#endif
